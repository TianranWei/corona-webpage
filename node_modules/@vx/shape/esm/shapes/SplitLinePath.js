import _pt from "prop-types";

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

import React from 'react';
import LinePath from './LinePath';
import getLineSegments from './getLineSegments';
export default function SplitLinePath(_ref) {
  var children = _ref.children,
      curve = _ref.curve,
      segments = _ref.data,
      defined = _ref.defined,
      x = _ref.x,
      y = _ref.y,
      styles = _ref.styles;
  // combine data to first draw entire path
  var flatData = segments.reduce(function (flat, segmentData) {
    return flat.concat([].concat(segmentData));
  }, []);
  return React.createElement(LinePath, {
    data: flatData,
    defined: defined,
    curve: curve,
    x: x,
    y: y
  }, function (_ref2) {
    var path = _ref2.path;
    var wholePath = path(flatData);
    var computedLineSegments = getLineSegments(wholePath || '', segments);
    return computedLineSegments.map(function (segment, i) {
      return React.createElement(React.Fragment, {
        key: i
      }, children ? children({
        index: i,
        segment: segment,
        styles: styles[i] || styles[i % styles.length]
      }) : React.createElement(LinePath, _extends({
        key: i,
        data: segment,
        x: function x(d) {
          return d.x || 0;
        },
        y: function y(d) {
          return d.y || 0;
        }
      }, styles[i] || styles[i % styles.length])));
    });
  });
}
SplitLinePath.propTypes = {
  data: _pt.arrayOf(_pt.arrayOf(_pt.any)).isRequired,
  styles: _pt.arrayOf(_pt.any).isRequired,
  curve: _pt.any,
  defined: _pt.func,
  x: _pt.func,
  y: _pt.func,
  children: _pt.func
};