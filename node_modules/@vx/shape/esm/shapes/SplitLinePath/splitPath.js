import memoize from 'lodash/memoize';
var MEASUREMENT_ELEMENT_ID = '__vx_react_svg_text_measurement_id';
export function splitPath(pathSting, numPieces, pieceSize, sampleInterval) {
  if (sampleInterval === void 0) {
    sampleInterval = 0.25;
  }

  var pathNode = document.getElementById(MEASUREMENT_ELEMENT_ID);

  if (!pathNode) {
    var svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    svg.style.width = '0';
    svg.style.height = '0';
    svg.style.position = 'absolute';
    svg.style.top = '-100%';
    svg.style.left = '-100%';
    pathNode = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    pathNode.setAttribute('id', MEASUREMENT_ELEMENT_ID);
    svg.appendChild(pathNode);
  }

  var pathLength = pathNode.getTotalLength();
  var pieceSizes = Array.isArray(pieceSize) ? pieceSize : new Array(numPieces).fill(pieceSize);
  var sumPieceSizes = pieceSizes.reduce(function (a, b) {
    return a + b;
  }, 0);
  var sizeCoefficient = pathLength / sumPieceSizes;
  var cumulativeSize = 0;
  var pieces = [];
  pieceSizes.forEach(function (size, pieceIndex) {
    var segments = [];

    for (var i = 0; i <= size + sampleInterval; i += sampleInterval) {
      var point = pathNode.getPointAtLength(i * sizeCoefficient + cumulativeSize * sizeCoefficient);
      segments.push([point.x, point.y]);
    }

    var angle = Math.atan2(segments[1][1] - segments[0][1], segments[1][0] - segments[0][0]) * 180 / Math.PI;
    pieces.push({
      id: pieceIndex,
      segments: segments,
      angle: angle
    });
    cumulativeSize += size;
  });
  return pieces;
}
export default memoize(splitPath, function () {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  return JSON.stringify(args);
});